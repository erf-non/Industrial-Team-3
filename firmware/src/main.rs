mod display;
mod mqtt;
mod network;
mod piezo;
mod rfid;

use std::cell::{Cell, OnceCell};
use std::cmp::min;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use anyhow::Result;
use esp_idf_svc::eventloop::EspSystemEventLoop;
use esp_idf_svc::hal::prelude::Peripherals;
use log::{error, info};
//use std::io::{Read, Write};
use std::{default, thread};
use std::rc::Rc;
use std::sync::mpsc::{channel, RecvTimeoutError, TryRecvError};
//use std::future::join;
use std::time::Duration;
use esp_idf_hal::gpio::{Gpio18, Gpio19};
use esp_idf_hal::i2c::I2C0;
use esp_idf_hal::io::Read;
use esp_idf_hal::sys::sleep;

use crate::display::Display;
use crate::mqtt::MqttDisplayMessage;
use crate::piezo::{Piezo, Tone};
use crate::rfid::{FrameType, Rfid};
const AWS_CERT: &[u8] = const_str::concat_bytes!(include_bytes!("../cert.pem"), 0u8);
const AWS_PRIVKEY: &[u8] = const_str::concat_bytes!(include_bytes!("../privkey.pem"), 0u8);
const AWS_ROOT1: &[u8] = const_str::concat_bytes!(include_bytes!("../aws_root1.pem"), 0u8);
const TAG_TTL_INIT: u16 = 5;
const TAG_TTL_THRESH: u16 = 15;
const TAG_TTL_CAP: u16 = 20;
const TAG_TTL_END: u16 = 0;

type ProductMap = Arc<Mutex<HashMap<Vec<u8>, (bool, u16)>>>;

/// This configuration is picked up at compile time by `build.rs` from the
/// file `cfg.toml`. The constant `CONFIG` is auto-generated by `toml_config`.
#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
    #[default("")]
    aws_endpoint: &'static str,
    #[default("")]
    device_id: &'static str,
    #[default("")]
    web_frontend_url: &'static str
}

/// Entry point to our application.
///
/// It sets up a Wi-Fi connection to the Access Point given in the
/// configuration, then blinks the RGB LED green/blue.
///
/// If the LED goes solid red, then it was unable to connect to your Wi-Fi
/// network.
fn main() -> Result<()> {
    esp_idf_svc::sys::link_patches();   
   
    esp_idf_svc::log::EspLogger::initialize_default();
    unsafe { esp_idf_svc::sys::nvs_flash_init() };

    let mut peripherals = Peripherals::take().unwrap();
    //let mut products: HashMap<[u8], (bool, u16)> = Default::default();

    let cell: ProductMap = Default::default();
    let sysloop = EspSystemEventLoop::take()?;

    // hardware i2c bus 0, sda pin 19, scl pin 18
    //let mut display =
    //    Display::init(peripherals.i2c0, peripherals.pins.gpio19, peripherals.pins.gpio18);
    
    let mut piezo = 
        Piezo::init(peripherals.pins.gpio21, peripherals.ledc.timer0, peripherals.ledc.channel0);
    
    // hardware uart1 bus, uart0 used for usb
    let mut rfid =
        Rfid::init(peripherals.uart1, peripherals.pins.gpio10, peripherals.pins.gpio9);
    
    piezo.sound(Tone::E5, 220, 20);
    piezo.sound(Tone::A5, 220, 20);
    piezo.sound(Tone::E5, 220, 20);
    piezo.sound(Tone::B5, 220, 20);
    piezo.sound(Tone::B5, 220, 20);
    
    //display.text_demo("connecting...");
    let _wifi = loop {
        // Connect to the Wi-Fi network
        match network::wifi_conn(
            CONFIG.wifi_ssid,
            CONFIG.wifi_psk,
            &mut peripherals.modem,
            sysloop.clone(),
        ) {
            Ok(inner) => break inner,
            Err(err) => {
                error!("Could not connect to Wi-Fi network: {:?}, trying again...", err);
                std::thread::sleep(std::time::Duration::from_secs(1));
            }
        }
    };

    let thread_products = cell.clone();
    let thread_handle = thread::Builder::new().stack_size(9216).spawn(move || thread2(thread_products, peripherals.i2c0, peripherals.pins.gpio19, peripherals.pins.gpio18));


    loop {
        let frame = rfid.frame_scan_data_n(8);
        rfid.uart.write(&frame).unwrap();
        for i in 1..4096 {
            match rfid.read_frame() {
                Ok(Some(frame)) => {
                    assert_eq!(frame[0], 0xbbu8);
                    if (frame[1] == FrameType::Response as u8) {
                        // Handling errors etc...
                    } else if (frame[1] == FrameType::Notification as u8) {
                        match frame[2] {
                            0x22u8 => {
                                let payload_size = u16::from_be_bytes([frame[3], frame[4]]) as usize;
                                let epc = Vec::from(&frame[6..(payload_size + 4)]);

                                cell.lock().unwrap().entry(epc)
                                    .and_modify(|(flag, ttl)| *ttl = min(TAG_TTL_CAP, *ttl + 2))
                                    .or_insert((false, TAG_TTL_INIT));
                            },
                            _ => {
                                info!("Oopsie, unknown type of packet from the RFID reader");
                            },
                        }
                    }
                },
                Ok(None) => {}
                Err(n) => {
                    info!("{}", n);
                }
            };            
        }
        thread::sleep(Duration::from_millis(200));
    }

    info!("{:?}", rfid.read_frame());
    //thread_handle.join().expect("Joining secondary thread failed");

}

pub fn thread2(products: ProductMap, c0: I2C0, gpio19: Gpio19, gpio18: Gpio18) {

    //let mut peripherals = Peripherals::take().unwrap();
    
    let mut display =
        Display::init(c0, gpio19, gpio18);
    thread::sleep(Duration::from_secs(5));
    
    // display.text_message("Please wait");
    
    let (disp_tx, disp_rx) = channel();
    
    let mut connection = loop {
        match mqtt::Mqtt::connect(disp_tx.clone()) {
            Ok(n) => break n,
            _ => { info!("Retry MQTT connection"); thread::sleep(Duration::from_secs(1)); }
        }
    };

    let session_id = loop {
        match disp_rx.recv_timeout(Duration::from_secs(10)) {
            Ok(MqttDisplayMessage::Session(s)) => break s,
            Ok(_) => {},
            Err(_) => { panic!("Server failed to send session!") }
        }
    };

    display.display_qr_message(
        format!("{}{session_id}", CONFIG.web_frontend_url), "Welcome!", "Scan QR", "to begin").unwrap();

    products.lock().unwrap().iter_mut().for_each(|(_, (_, ttl))| *ttl = ttl.saturating_sub(1));
    loop {
        for (key, (flag, ttl)) in products.lock().unwrap().iter_mut() {

            if !*flag && *ttl > TAG_TTL_THRESH {
                *flag = true;
                connection.send_add_product(&key[..]);
                display.veryhappy_anim();
                info!("新品》\t{:?}\t{:?}\t{:?}", key, flag, ttl);
            }

            *ttl = ttl.saturating_sub(1);

            if *flag && *ttl == TAG_TTL_END {
                connection.send_remove_product(&key[..]);
                info!("老品》\t{:?}\t{:?}\t{:?}", key, flag, ttl);
            }
        }

        products.lock().unwrap().retain(|key, (flag, ttl)| *ttl > 0);
        //display.veryhappy_anim();
        thread::sleep(Duration::from_millis(250));
        match disp_rx.try_recv() {
            Ok(MqttDisplayMessage::Price(price)) => display.show_price(price),
            Ok(_) | Err(TryRecvError::Empty) => {},
            Err(TryRecvError::Disconnected) => panic!("display channel epic fail")
        }
    }

}