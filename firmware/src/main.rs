use std::{
    cmp::min,
    collections::HashMap,
    sync::{Arc, Mutex},
    sync::mpsc::{channel, TryRecvError},
    thread,
    time::Duration,
};

use esp_idf_hal::{
    gpio::{Gpio18, Gpio19},
    i2c::I2C0,
};
use esp_idf_svc::{
    eventloop::EspSystemEventLoop,
    hal::prelude::Peripherals,
};
use log::{error, info};

use crate::{
    display::Display,
    mqtt::MqttDisplayMessage,
    piezo::{Piezo, Tone},
    rfid::{FrameType, Rfid},
};

mod display;
mod mqtt;
mod network;
mod piezo;
mod rfid;

const TAG_TTL_INIT: u16 = 5;
const TAG_TTL_THRESH: u16 = 15;
const TAG_TTL_CAP: u16 = 20;
const TAG_TTL_END: u16 = 0;

const AWS_CERT: &[u8] = const_str::concat_bytes!(include_bytes!("../cert.pem"), 0u8);
const AWS_PRIVKEY: &[u8] = const_str::concat_bytes!(include_bytes!("../privkey.pem"), 0u8);
const AWS_ROOT1: &[u8] = const_str::concat_bytes!(include_bytes!("../aws_root1.pem"), 0u8);

type ProductMap = Arc<Mutex<HashMap<Vec<u8>, (bool, u16)>>>;

/// This configuration is picked up at compile time by `build.rs` from the
/// file `cfg.toml`. The constant `CONFIG` is auto-generated by `toml_config`.
#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
    #[default("")]
    aws_endpoint: &'static str,
    #[default("")]
    device_id: &'static str,
    #[default("")]
    web_frontend_url: &'static str
}

/// Entry point to our application.
///
/// It sets up a Wi-Fi connection to the Access Point given in the
/// configuration, then blinks the RGB LED green/blue.
///
/// If the LED goes solid red, then it was unable to connect to your Wi-Fi
/// network.
fn main() {
    esp_idf_svc::sys::link_patches();   
   
    esp_idf_svc::log::EspLogger::initialize_default();
    unsafe { esp_idf_svc::sys::nvs_flash_init() };

    let mut peripherals = Peripherals::take().unwrap();

    let cell: ProductMap = Default::default();
    let sysloop = EspSystemEventLoop::take().unwrap();
    
    let mut piezo = 
        Piezo::init(peripherals.pins.gpio21, peripherals.ledc.timer0, peripherals.ledc.channel0);
    
    // hardware uart1 bus, uart0 used for usb
    let mut rfid =
        Rfid::init(peripherals.uart1, peripherals.pins.gpio10, peripherals.pins.gpio9);
    
    piezo.sound(Tone::E5, 220, 20);
    piezo.sound(Tone::A5, 220, 20);
    piezo.sound(Tone::E5, 220, 20);
    piezo.sound(Tone::B5, 220, 20);
    piezo.sound(Tone::B5, 220, 20);
    
    //display.text_demo("connecting...");
    let _wifi = loop {
        // Connect to the Wi-Fi network
        match network::wifi_conn(
            CONFIG.wifi_ssid,
            CONFIG.wifi_psk,
            &mut peripherals.modem,
            sysloop.clone(),
        ) {
            Ok(inner) => break inner,
            Err(err) => {
                error!("Could not connect to Wi-Fi network: {:?}, trying again...", err);
                std::thread::sleep(std::time::Duration::from_secs(1));
            }
        }
    };

    let thread_products = cell.clone();
    let thread_handle = thread::Builder::new().stack_size(9216).spawn(move || mqtt_display_thread(thread_products, peripherals.i2c0, peripherals.pins.gpio19, peripherals.pins.gpio18));

    rfid_loop(cell, &mut rfid);

    thread_handle.unwrap().join().expect("Joining secondary thread failed");
}

fn rfid_loop(cell: ProductMap, rfid: &mut Rfid) {
    loop {
        let frame = rfid.frame_scan_data_n(8);
        rfid.uart.write(&frame).unwrap();
        for _i in 1..4096 {
            match rfid.read_frame() {
                Ok(Some(frame)) => {
                    assert_eq!(frame[0], 0xbbu8);
                    if frame[1] == FrameType::Response as u8 {
                        // Handling errors etc...
                    } else if frame[1] == FrameType::Notification as u8 {
                        match frame[2] {
                            0x22u8 => {
                                let payload_size = u16::from_be_bytes([frame[3], frame[4]]) as usize;
                                let epc = Vec::from(&frame[6..(payload_size + 4)]);

                                cell.lock().unwrap().entry(epc)
                                    .and_modify(|(_flag, ttl)| *ttl = min(TAG_TTL_CAP, *ttl + 2))
                                    .or_insert((false, TAG_TTL_INIT));
                            },
                            _ => {
                                info!("Oopsie, unknown type of packet from the RFID reader");
                            },
                        }
                    }
                },
                Ok(None) => {}
                Err(n) => {
                    info!("{}", n);
                }
            };
        }
        thread::sleep(Duration::from_millis(200));
    }
}

pub fn mqtt_display_thread(products: ProductMap, c0: I2C0, gpio19: Gpio19, gpio18: Gpio18) {
    let mut display =
        Display::init(c0, gpio19, gpio18);
    thread::sleep(Duration::from_secs(5));
    
    // display.text_message("Please wait");
    
    let (disp_tx, disp_rx) = channel();
    
    let mut connection = loop {
        match mqtt::Mqtt::connect(disp_tx.clone()) {
            Ok(n) => break n,
            _ => { info!("Retry MQTT connection"); thread::sleep(Duration::from_secs(1)); }
        }
    };

    let session_id = loop {
        match disp_rx.recv_timeout(Duration::from_secs(10)) {
            Ok(MqttDisplayMessage::Session(s)) => break s,
            Ok(_) => {},
            Err(_) => { panic!("Server failed to send session!") }
        }
    };

    display.display_qr_message(
        format!("{}{session_id}", CONFIG.web_frontend_url), "Welcome!", "Scan QR", "to begin").unwrap();

    products.lock().unwrap().iter_mut().for_each(|(_, (_, ttl))| *ttl = ttl.saturating_sub(1));
    loop {
        for (key, (flag, ttl)) in products.lock().unwrap().iter_mut() {

            if !*flag && *ttl > TAG_TTL_THRESH {
                *flag = true;
                connection.send_add_product(&key[..]);
                display.veryhappy_anim();
                info!("新品》\t{:?}\t{:?}\t{:?}", key, flag, ttl);
            }

            *ttl = ttl.saturating_sub(1);

            if *flag && *ttl == TAG_TTL_END {
                connection.send_remove_product(&key[..]);
                info!("老品》\t{:?}\t{:?}\t{:?}", key, flag, ttl);
            }
        }

        products.lock().unwrap().retain(|_key, (_flag, ttl)| *ttl > 0);
        //display.veryhappy_anim();
        thread::sleep(Duration::from_millis(250));
        match disp_rx.try_recv() {
            Ok(MqttDisplayMessage::Price(price)) => display.show_price(price),
            Ok(_) | Err(TryRecvError::Empty) => {},
            Err(TryRecvError::Disconnected) => panic!("display channel epic fail")
        }
    }
}
